// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Moment from "moment";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as MomentRe from "bs-moment/lib/es6/src/MomentRe.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_splice_call from "bs-platform/lib/es6/caml_splice_call.js";
import * as Date$DoctolibKnex from "./Date.bs.js";
import * as Sqlite3$DoctolibKnex from "./Sqlite3.bs.js";

function dayToJs(param) {
  return param;
}

function is(day, date) {
  return date.getDay() === day;
}

function isSaturday(date) {
  return is(/* Saturday */6, date);
}

function isWithinInterval(interval, date) {
  var ts = Date$DoctolibKnex.copy(date).getTime();
  if (ts >= Date$DoctolibKnex.copy(interval.start).getTime()) {
    return ts <= Date$DoctolibKnex.copy(interval.end_).getTime();
  } else {
    return false;
  }
}

function makeInterval(start, end_) {
  return {
          start: start,
          end_: end_
        };
}

function decodeEvent(r) {
  console.log(r);
  var event_starts = new Date(r.starts_at);
  var event_ends = new Date(r.ends_at);
  var event_weekly_recurring = r.weekly_recurring;
  var $$event = {
    starts: event_starts,
    ends: event_ends,
    weekly_recurring: event_weekly_recurring
  };
  console.log("event", $$event);
  return $$event;
}

function makeYMD(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

function makeResult(r, date) {
  var rangeStart = Date$DoctolibKnex.addDays(date, -1);
  var data = Belt_Array.map(r, decodeEvent);
  console.log("data", data);
  var appointments = Caml_array.caml_array_get(data, 1);
  var apptStart = MomentRe.moment([], appointments.starts.toString());
  var hasAppointments = apptStart.isSame(Moment(date.toString()), "day");
  var arrayInitNextWeek = function (date) {
    return $$Array.init(7, (function (index) {
                  var __x = index + 1 | 0;
                  var date$1 = Date$DoctolibKnex.addDays(date, __x);
                  return {
                          date: date$1,
                          slots: []
                        };
                }));
  };
  var availabilities = arrayInitNextWeek(rangeStart);
  var match = Caml_array.caml_array_get(data, 0);
  var starts = match.starts;
  var weekRangeEnd = Date$DoctolibKnex.addDays(starts, 7);
  var weekInterval_start = makeYMD(starts);
  var weekInterval = {
    start: weekInterval_start,
    end_: weekRangeEnd
  };
  var generateApptSlots = function ($$event) {
    var formattedApptSlots = [];
    var starts = $$event.starts;
    var slotInterval_end_ = $$event.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (date) {
      if (isWithinInterval(slotInterval, date)) {
        if (hasAppointments) {
          console.log("hasAppointments_rec_true");
        } else {
          console.log("hasAppointments_rec_false");
        }
        var starts = Date$DoctolibKnex.addMinutes(date, 30);
        var hours = starts.toString();
        var formattedSlot = MomentRe.moment(undefined, hours);
        formattedApptSlots.push(formattedSlot);
        var __x = Date$DoctolibKnex.copy(date);
        slot(Date$DoctolibKnex.addMinutes(__x, 30));
        return /* () */0;
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedApptSlots;
  };
  var generateSlots = function ($$event) {
    var formattedSlots = [];
    var starts = $$event.starts;
    var slotInterval_end_ = $$event.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (date) {
      if (isWithinInterval(slotInterval, date)) {
        var starts = Date$DoctolibKnex.addMinutes(date, 30);
        var hours = starts.toString();
        var formattedSlot = MomentRe.moment(undefined, hours);
        formattedSlots.push(formattedSlot);
        var __x = Date$DoctolibKnex.copy(date);
        slot(Date$DoctolibKnex.addMinutes(__x, 30));
        return /* () */0;
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedSlots;
  };
  if (match.weekly_recurring) {
    console.log(true);
    var newSlots = generateSlots(Caml_array.caml_array_get(data, 0));
    var newApptSlots = generateApptSlots(Caml_array.caml_array_get(data, 1));
    Belt_Array.map(availabilities, (function (a) {
            var isSaturday = is(/* Saturday */6, a.date);
            var isInInterval = isWithinInterval(weekInterval, a.date);
            var apptInterval_start = appointments.starts;
            var apptInterval_end_ = appointments.ends;
            var apptInterval = {
              start: apptInterval_start,
              end_: apptInterval_end_
            };
            var apptStart = Moment(appointments.starts.toString());
            var aDate = Moment(a.date.toString());
            var hasAppointments = apptStart.isSame(aDate, "day");
            var slotsToDate = Belt_Array.map(newSlots, (function (s) {
                    return s.toDate();
                  }));
            console.log("slotsToDate", slotsToDate);
            var handleSlotInterval = Belt_Array.map(slotsToDate, (function (s) {
                    return isWithinInterval(apptInterval, s);
                  }));
            console.log("handleSlotInterval", handleSlotInterval);
            Belt_Array.map(newSlots, (function (s) {
                    return s.format();
                  }));
            Belt_Array.map(newApptSlots, (function (s) {
                    return s.format();
                  }));
            console.log("apptInterval", apptInterval);
            var test2 = Belt_Array.map(newSlots, (function (slot) {
                    var slot$1 = slot;
                    return Belt_Array.keepMap(newApptSlots, (function (x) {
                                  if (x !== slot$1) {
                                    return Caml_option.some(x);
                                  }
                                  
                                }));
                  }));
            console.log("test2", Caml_array.caml_array_get(test2, 0));
            console.log(Belt_Array.cmp(newSlots, newApptSlots, Caml_obj.caml_compare));
            if (hasAppointments) {
              console.log("hasAppointments", newSlots.filter((function (x) {
                          return !$$Array.mem(x, newApptSlots);
                        })));
            }
            if (isSaturday || !isInInterval) {
              return 0;
            } else {
              return Caml_splice_call.spliceObjApply(a.slots, "push", [newSlots]);
            }
          }));
  }
  return availabilities;
}

var db = Sqlite3$DoctolibKnex.Database.make("db.sqlite", undefined, undefined, (function (prim) {
        console.log(prim);
        return /* () */0;
      }), true, /* () */0);

function getAvailabilities(date) {
  console.log("getdate", date);
  console.log("getdate", date.getDay());
  var data = db.prepare("select * from `events`").all();
  var availabilities = makeResult(data, date);
  console.log("get_availabilities_result", availabilities);
  return availabilities;
}

var date = new Date("2014-08-10");

getAvailabilities(date);

export {
  dayToJs ,
  is ,
  isSaturday ,
  isWithinInterval ,
  makeInterval ,
  decodeEvent ,
  makeYMD ,
  makeResult ,
  db ,
  getAvailabilities ,
  date ,
  
}
/* db Not a pure module */
