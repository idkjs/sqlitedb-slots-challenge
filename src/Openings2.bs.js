// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Moment = require("moment");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var MomentRe = require("bs-moment/src/MomentRe.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Date$DoctolibKnex = require("./Date.bs.js");
var Sqlite3$DoctolibKnex = require("./Sqlite3.bs.js");

function dayToJs(param) {
  return param;
}

function is(day, date) {
  return date.getDay() === day;
}

function isSaturday(date) {
  return is(/* Saturday */6, date);
}

function isWithinInterval(interval, date) {
  var ts = Date$DoctolibKnex.copy(date).getTime();
  if (ts >= Date$DoctolibKnex.copy(interval.start).getTime()) {
    return ts <= Date$DoctolibKnex.copy(interval.end_).getTime();
  } else {
    return false;
  }
}

function makeInterval(start, end_) {
  return {
          start: start,
          end_: end_
        };
}

function decodeEvent(r) {
  console.log(r);
  var event_starts = new Date(r.starts_at);
  var event_ends = new Date(r.ends_at);
  var event_weekly_recurring = r.weekly_recurring;
  var $$event = {
    starts: event_starts,
    ends: event_ends,
    weekly_recurring: event_weekly_recurring
  };
  console.log("event", $$event);
  return $$event;
}

function makeYMD(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

function makeResult(r, date) {
  var rangeStart = Date$DoctolibKnex.addDays(date, -1);
  var data = Belt_Array.map(r, decodeEvent);
  console.log("data", data);
  var appointments = Caml_array.caml_array_get(data, 1);
  var apptStart = MomentRe.moment([], appointments.starts.toString());
  var hasAppointments = apptStart.isSame(Moment(date.toString()), "day");
  var arrayInitNextWeek = function (date) {
    return $$Array.init(7, (function (index) {
                  var __x = index + 1 | 0;
                  var date$1 = Date$DoctolibKnex.addDays(date, __x);
                  return {
                          date: date$1,
                          slots: []
                        };
                }));
  };
  var availabilities = arrayInitNextWeek(rangeStart);
  var match = Caml_array.caml_array_get(data, 0);
  var starts = match.starts;
  var weekRangeEnd = Date$DoctolibKnex.addDays(starts, 7);
  var weekInterval_start = makeYMD(starts);
  var weekInterval = {
    start: weekInterval_start,
    end_: weekRangeEnd
  };
  var generateApptSlots = function ($$event) {
    var formattedApptSlots = [];
    var starts = $$event.starts;
    var slotInterval_end_ = $$event.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (date) {
      if (isWithinInterval(slotInterval, date)) {
        if (hasAppointments) {
          console.log("hasAppointments_rec_true");
        } else {
          console.log("hasAppointments_rec_false");
        }
        var starts = Date$DoctolibKnex.addMinutes(date, 30);
        var hours = starts.toString();
        var formattedSlot = MomentRe.moment(undefined, hours);
        formattedApptSlots.push(formattedSlot);
        var __x = Date$DoctolibKnex.copy(date);
        slot(Date$DoctolibKnex.addMinutes(__x, 30));
        return /* () */0;
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedApptSlots;
  };
  var generateSlots = function ($$event) {
    var formattedSlots = [];
    var starts = $$event.starts;
    var slotInterval_end_ = $$event.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (date) {
      if (isWithinInterval(slotInterval, date)) {
        var starts = Date$DoctolibKnex.addMinutes(date, 30);
        var hours = starts.toString();
        var formattedSlot = MomentRe.moment(undefined, hours);
        formattedSlots.push(formattedSlot);
        var __x = Date$DoctolibKnex.copy(date);
        slot(Date$DoctolibKnex.addMinutes(__x, 30));
        return /* () */0;
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedSlots;
  };
  if (match.weekly_recurring) {
    console.log(true);
    var newSlots = generateSlots(Caml_array.caml_array_get(data, 0));
    var newApptSlots = generateApptSlots(Caml_array.caml_array_get(data, 1));
    Belt_Array.map(availabilities, (function (a) {
            var isSaturday = is(/* Saturday */6, a.date);
            var isInInterval = isWithinInterval(weekInterval, a.date);
            var apptInterval_start = appointments.starts;
            var apptInterval_end_ = appointments.ends;
            var apptInterval = {
              start: apptInterval_start,
              end_: apptInterval_end_
            };
            var apptStart = Moment(appointments.starts.toString());
            var aDate = Moment(a.date.toString());
            var hasAppointments = apptStart.isSame(aDate, "day");
            var slotsToDate = Belt_Array.map(newSlots, (function (s) {
                    return s.toDate();
                  }));
            console.log("slotsToDate", slotsToDate);
            var handleSlotInterval = Belt_Array.map(slotsToDate, (function (s) {
                    return isWithinInterval(apptInterval, s);
                  }));
            console.log("handleSlotInterval", handleSlotInterval);
            Belt_Array.map(newSlots, (function (s) {
                    return s.format();
                  }));
            Belt_Array.map(newApptSlots, (function (s) {
                    return s.format();
                  }));
            console.log("apptInterval", apptInterval);
            var test2 = Belt_Array.map(newSlots, (function (slot) {
                    var slot$1 = slot;
                    return Belt_Array.keepMap(newApptSlots, (function (x) {
                                  if (x !== slot$1) {
                                    return Caml_option.some(x);
                                  }
                                  
                                }));
                  }));
            console.log("test2", Caml_array.caml_array_get(test2, 0));
            console.log(Belt_Array.cmp(newSlots, newApptSlots, Caml_obj.caml_compare));
            if (hasAppointments) {
              console.log("hasAppointments", newSlots.filter((function (x) {
                          return !$$Array.mem(x, newApptSlots);
                        })));
            }
            if (isSaturday || !isInInterval) {
              return 0;
            } else {
              return Caml_splice_call.spliceObjApply(a.slots, "push", [newSlots]);
            }
          }));
  }
  return availabilities;
}

var db = Sqlite3$DoctolibKnex.Database.make("db.sqlite", undefined, undefined, (function (prim) {
        console.log(prim);
        return /* () */0;
      }), true, /* () */0);

function getAvailabilities(date) {
  console.log("getdate", date);
  console.log("getdate", date.getDay());
  var data = db.prepare("select * from `events`").all();
  var availabilities = makeResult(data, date);
  console.log("get_availabilities_result", availabilities);
  return availabilities;
}

var date = new Date("2014-08-10");

getAvailabilities(date);

exports.dayToJs = dayToJs;
exports.is = is;
exports.isSaturday = isSaturday;
exports.isWithinInterval = isWithinInterval;
exports.makeInterval = makeInterval;
exports.decodeEvent = decodeEvent;
exports.makeYMD = makeYMD;
exports.makeResult = makeResult;
exports.db = db;
exports.getAvailabilities = getAvailabilities;
exports.date = date;
/* db Not a pure module */
