// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Moment = require("moment");
var MomentRe = require("bs-moment/src/MomentRe.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Date$DoctolibKnex = require("./Date.bs.js");
var Sqlite3$DoctolibKnex = require("./Sqlite3.bs.js");

function dayToJs(param) {
  return param;
}

function is(day, date) {
  return date.getDay() === day;
}

function isSaturday(date) {
  return is(/* Saturday */6, date);
}

function isWithinInterval(interval, date) {
  var ts = Date$DoctolibKnex.copy(date).getTime();
  if (ts >= Date$DoctolibKnex.copy(interval.start).getTime()) {
    return ts <= Date$DoctolibKnex.copy(interval.end_).getTime();
  } else {
    return false;
  }
}

function makeInterval(start, end_) {
  return {
          start: start,
          end_: end_
        };
}

function decodeEvent(r) {
  console.log(r);
  var event_kind = r.kind;
  var event_starts = new Date(r.starts_at);
  var event_ends = new Date(r.ends_at);
  var event_weekly_recurring = r.weekly_recurring;
  var $$event = {
    kind: event_kind,
    starts: event_starts,
    ends: event_ends,
    weekly_recurring: event_weekly_recurring
  };
  console.log("event", $$event);
  return $$event;
}

function makeYMD(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

function formatDate(date) {
  return MomentRe.moment([], date.toString());
}

function makeResult(r, date) {
  var rangeStart = Date$DoctolibKnex.addDays(date, -1);
  var data = Belt_Array.map(r, decodeEvent);
  console.log("data", data);
  Belt_Array.keepMap(data, (function (d) {
          return d.kind === "appointment";
        }));
  var openings = Belt_Array.keepMap(data, (function (x) {
          var match = x.kind === "opening";
          if (match) {
            return x;
          }
          
        }));
  var appointments = Belt_Array.keepMap(data, (function (x) {
          var match = x.kind === "appointment";
          if (match) {
            return x;
          }
          
        }));
  var appointment = Caml_array.caml_array_get(appointments, 0);
  var appt_start = makeYMD(appointment.starts);
  var appt_start2 = MomentRe.moment(["YYYY-MM-DD"], makeYMD(appointment.starts).toString());
  var appt_start3 = makeYMD(appointment.starts);
  console.log("appt_start3", appt_start3);
  MomentRe.moment([], appointment.starts.toString());
  var aDate2 = function (date) {
    return MomentRe.moment(["YYYY-MM-DD"], makeYMD(date).toString());
  };
  Moment(appt_start).isSame(Moment(date), "day");
  appt_start2.isSame(aDate2(date), "day");
  MomentRe.moment(undefined, makeYMD(date).toString()).isSame(MomentRe.moment(undefined, appt_start3.toString()));
  var arrayInitNextWeek = function (date) {
    return $$Array.init(7, (function (index) {
                  var __x = index + 1 | 0;
                  var date$1 = Date$DoctolibKnex.addDays(date, __x);
                  return {
                          date: date$1,
                          slots: []
                        };
                }));
  };
  var availabilities = arrayInitNextWeek(rangeStart);
  var match = Caml_array.caml_array_get(data, 0);
  var starts = match.starts;
  var weekRangeEnd = Date$DoctolibKnex.addDays(starts, 7);
  var weekInterval_start = makeYMD(starts);
  var weekInterval = {
    start: weekInterval_start,
    end_: weekRangeEnd
  };
  var generateApptSlots = function (param) {
    var formattedApptSlots = [];
    var starts = appointment.starts;
    var slotInterval_end_ = appointment.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (date) {
      if (isWithinInterval(slotInterval, date)) {
        var starts = Date$DoctolibKnex.addMinutes(date, 30);
        var hours = starts.toString();
        var formattedSlot = MomentRe.moment(undefined, hours).format("h:mm");
        formattedApptSlots.push(formattedSlot);
        var __x = Date$DoctolibKnex.copy(date);
        slot(Date$DoctolibKnex.addMinutes(__x, 30));
        return /* () */0;
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedApptSlots;
  };
  var generateSlots = function (eventToCheck) {
    var formattedSlots = [];
    var starts = eventToCheck.starts;
    var slotInterval_end_ = eventToCheck.ends;
    var slotInterval = {
      start: starts,
      end_: slotInterval_end_
    };
    var slot = function (dateToCheck) {
      var makeIsSameDateToCheck = makeYMD(dateToCheck).toString();
      if (isWithinInterval(slotInterval, dateToCheck)) {
        if (MomentRe.moment(undefined, makeIsSameDateToCheck).isSame(MomentRe.moment(undefined, appt_start3.toString()))) {
          console.log("hasAppointments_rec_true", dateToCheck, true);
          var formattedApptSlots = [];
          console.log("formattedSlots_empty", formattedApptSlots);
          var starts = Date$DoctolibKnex.addMinutes(dateToCheck, 30);
          var hours = starts.toString();
          var formattedSlot = MomentRe.moment(undefined, hours).format("h:mm");
          formattedApptSlots.push(formattedSlot);
          console.log("formattedSlot", formattedSlot);
          console.log("formattedApptSlots_before", formattedApptSlots);
          var badSlots = generateApptSlots(/* () */0);
          formattedApptSlots.filter((function (x) {
                  return !$$Array.mem(x, badSlots);
                }));
          console.log("formattedApptSlots_filtered", formattedApptSlots);
          console.log("badSlots", badSlots);
          var filteredSlots = formattedApptSlots.filter((function (x) {
                  return !$$Array.mem(x, badSlots);
                }));
          console.log("filteredSlots", filteredSlots);
          formattedSlots.concat(filteredSlots);
          console.log("formattedSlots_filtered", formattedSlots);
          var __x = Date$DoctolibKnex.copy(dateToCheck);
          slot(Date$DoctolibKnex.addMinutes(__x, 30));
          return /* () */0;
        } else {
          var starts$1 = Date$DoctolibKnex.addMinutes(dateToCheck, 30);
          var hours$1 = starts$1.toString();
          var formattedSlot$1 = MomentRe.moment(undefined, hours$1).format("h:mm");
          formattedSlots.push(formattedSlot$1);
          var __x$1 = Date$DoctolibKnex.copy(dateToCheck);
          slot(Date$DoctolibKnex.addMinutes(__x$1, 30));
          return /* () */0;
        }
      } else {
        return /* () */0;
      }
    };
    slot(starts);
    return formattedSlots;
  };
  var makeSlotTime = function (date, hours, minutes) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes);
  };
  Belt_Array.map(availabilities, (function (a) {
          var isSaturday = is(/* Saturday */6, a.date);
          var isInInterval = isWithinInterval(weekInterval, a.date);
          var slotStartHours = Caml_array.caml_array_get(openings, 0).starts.getHours();
          var slotStartMinutes = Caml_array.caml_array_get(openings, 0).starts.getMinutes();
          var slotEndsHours = Caml_array.caml_array_get(openings, 0).ends.getHours();
          var slotEndsMinutes = Caml_array.caml_array_get(openings, 0).ends.getMinutes();
          var starts = makeSlotTime(a.date, slotStartHours, slotStartMinutes);
          var ends = makeSlotTime(a.date, slotEndsHours, slotEndsMinutes);
          console.log("MomentIsSame", MomentRe.moment(undefined, makeYMD(a.date).toString()).isSame(MomentRe.moment(undefined, appt_start3.toString())));
          console.log("currentDate", starts);
          var init = Caml_array.caml_array_get(openings, 0);
          var currentEvent_kind = init.kind;
          var currentEvent_weekly_recurring = init.weekly_recurring;
          var currentEvent = {
            kind: currentEvent_kind,
            starts: starts,
            ends: ends,
            weekly_recurring: currentEvent_weekly_recurring
          };
          var newSlots = generateSlots(currentEvent);
          console.log("appointment.starts", appointment.starts.getTime());
          if (isSaturday || !isInInterval) {
            return 0;
          } else {
            return Caml_splice_call.spliceObjApply(a.slots, "push", [newSlots]);
          }
        }));
  return availabilities;
}

var db = Sqlite3$DoctolibKnex.Database.make("db.sqlite", undefined, undefined, (function (prim) {
        console.log(prim);
        return /* () */0;
      }), true, /* () */0);

function getAvailabilities(date) {
  console.log("getdate", date);
  console.log("getdate", date.getDay());
  var data = db.prepare("select * from `events`").all();
  var availabilities = makeResult(data, date);
  console.log("get_availabilities_result", availabilities);
  return availabilities;
}

var date = new Date("2014-08-10");

getAvailabilities(date);

exports.dayToJs = dayToJs;
exports.is = is;
exports.isSaturday = isSaturday;
exports.isWithinInterval = isWithinInterval;
exports.makeInterval = makeInterval;
exports.decodeEvent = decodeEvent;
exports.makeYMD = makeYMD;
exports.formatDate = formatDate;
exports.makeResult = makeResult;
exports.db = db;
exports.getAvailabilities = getAvailabilities;
exports.date = date;
/* db Not a pure module */
